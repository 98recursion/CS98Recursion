Recursive Binary Search

Do you recall how in the first lecture, we found the page with my address and phone number by taking the phone book, tearing it in half, throwing away the half that did not contain my listing, and repeating this procedure until only one page remained, and that page had to have my listing (assuming of course, that my phone number is listed, which it is)?

I didn't say it but this idea can be programed as a recursive method.

It is important to remember that recursive implementations require base cases and recursive cases. So what was the base case when I was looking for my listing in the phone book? I eventually ended up with the page containing my listing. If we did a binary search on the phone book for someone who doesn't exist, for example Sponge Bob Square Pants, we would end up with a page that doesn’t have his number and address. Alright, so the base case for recursive binary search is that the last element either contains or does not contain the element we are searching for.

Now, what was the recursive case? We ripped the phone book in half and checked which side would contain my listing. Then we took the side that we though might have my listing and treated it just like a new phone book and ripped that in half and repeated the process until we were left with one page. So the recursive case is to perform a binary search on the remaining collection of elements that hopefully contains the element we are searching for based on the assessment of which half our element is more likely to be on.

Here is some code to do a recursive binary search:
[CODE HERE]

The function takes a sorted array of numbers, a key to search for, and optionally indices bounds left and right on the array of numbers. The first if statement is really only there if you want to do a binary search on the entire array of numbers otherwise it is not run on recursive calls(when the function calls its self) becuase the recursive calls supply indices.

As you can see in the sample code, there is a bit of index manipulation. The outer if statement acts as a base case for when a binary search is called on an empty array where it returns null because the key was not found. If the array is not empty we calculate a midpoint index in the array. In our implementation, when the array size is odd, we make the midpoint the median number, when it is even it is the largest number of the smaller half.
[1, 2, 3, 4, 5] 3 would be the midpoint.
[1, 2, 3, 4], 2 would be the midpoint.
If the midpoint number is equal to the key we have found the key so we return the midpoint index. If the midpoint number is greater than the key we do a binary search on the numbers between the left index and left of the midpoint. Otherwise, we do a binary search on the numbers between right of the midpoint and the right index.


[VISUALIZATION IMAGE HERE]